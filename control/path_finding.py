import numpy as np
from typing import List


def path_finding(triangles: np.ndarray, cones: List[dict]):
    """
    This function will take a list of triangles between cones, generated by Delaunay triangularization. This is
    converted to an array of edges between cones of opposite color. Then it first finds the order in which they
    are positioned on the track. Secondly, it will determine the midpoints between of the edges and return them
    as an ordered list, with the first element being the first upcoming midpoint.

    :param triangles: np.ndarray([n1, n2, n3]) – n1, n2, n3 in natural numbers; numbers represent position in list cones
    :param cones: ordered list of dictionaries describing cones (ordered by colour and then distance to car);
                  dictionary entries:
                    ...
    :return midpoints: np.ndarray[p] – p = np.array([x, y]) – x, y in natural numbers
    """

    midpoints = []
    for triangle in triangles:
        if cones[triangle[0]]["Label"] != cones[triangle[1]]["Label"]:
            midpoints.append([(cones[triangle[0]]["Xpos"] + cones[triangle[1]]["Xpos"]) / 2,
                             (cones[triangle[0]]["Ypos"] + cones[triangle[1]]["Ypos"]) / 2])
        if cones[triangle[2]]["Label"] != cones[triangle[1]]["Label"]:
            midpoints.append([(cones[triangle[2]]["Xpos"] + cones[triangle[1]]["Xpos"]) / 2,
                             (cones[triangle[2]]["Ypos"] + cones[triangle[1]]["Ypos"]) / 2])
        if cones[triangle[2]]["Label"] != cones[triangle[0]]["Label"]:
            midpoints.append([(cones[triangle[0]]["Xpos"] + cones[triangle[2]]["Xpos"]) / 2,
                             (cones[triangle[0]]["Ypos"] + cones[triangle[2]]["Ypos"]) / 2])

    unique_midpoints = []
    for midpoint in midpoints:
        if midpoint not in unique_midpoints:
            unique_midpoints.append(midpoint)

    midpoints = unique_midpoints

    distances = [p[0]**2 + p[1]**2 for p in midpoints]
    idx = distances.index(min(distances))
    current_midpoint = midpoints[idx]
    used_indexes = [idx]
    ordered_midpoints = [current_midpoint]
    for i in range(1, len(midpoints)):
        next_idx = None
        next_distance = np.infty
        for j in range(len(midpoints)):
            if j in used_indexes:
                continue
            t = np.sqrt((midpoints[j][0] - current_midpoint[0]) ** 2 + (midpoints[j][1] - current_midpoint[1]) ** 2)
            if t < next_distance:
                next_distance = t
                next_idx = j
        if next_idx is not None:
            current_midpoint = midpoints[next_idx]
            ordered_midpoints.append(current_midpoint)
            used_indexes.append(next_idx)

    """for i in range(1, midpoints.shape[0]):
        found_next_edge = False
        for j in range(edges.shape[0]):
            if j in used_indexes:
                continue
            if np.all(edges[j][0] == current_edge[1]) or np.all(edges[j][1] == current_edge[1]) \
                    or np.all(edges[j][0] == current_edge[0]) or np.all(edges[j][0] == current_edge[0]):
                current_edge = edges[j]
                ordered_edges.append(current_edge)
                used_indexes.append(j)
                found_next_edge = True
                break
        if not found_next_edge:
            break

    midpoints = np.average(ordered_edges, axis=1)"""

    return np.array(ordered_midpoints)

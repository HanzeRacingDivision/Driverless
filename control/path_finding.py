import numpy as np
from typing import List


def path_finding(triangles: np.ndarray, cones: List[dict]):
    """
    This function will take a list of triangles between cones, generated by Delaunay triangularization. This is
    converted to an array of edges between cones of opposite color. Then it first finds the order in which they
    are positioned on the track. Secondly, it will determine the midpoints between of the edges and return them
    as an ordered list, with the first element being the first upcoming midpoint.

    :param triangles: np.ndarray([n1, n2, n3]); n1, n2 and n3 is integers; numbers represent position in the list cones
    :param cones: ordered list of dictionaries describing cones (ordered by colour and then distance to car);
                  dictionary key-value pairs:
                    "Label": str ("Yellow" or "Blue")
                    "Xpos": float
                    "Ypos": float
    :return midpoints: np.ndarray[[x, y]]; x and y as floats
    """

    edges = []
    for triangle in triangles:
        if cones[triangle[0]]["Label"] != cones[triangle[1]]["Label"]:
            edge = sorted([[cones[triangle[0]]["Xpos"], cones[triangle[0]]["Ypos"]],
                           [cones[triangle[1]]["Xpos"], cones[triangle[1]]["Ypos"]]], key=lambda x: x[0]**2 + x[1]**2)
            if edge not in edges:
                edges.append(edge)
        if cones[triangle[2]]["Label"] != cones[triangle[1]]["Label"]:
            edge = sorted([[cones[triangle[2]]["Xpos"], cones[triangle[2]]["Ypos"]],
                           [cones[triangle[1]]["Xpos"], cones[triangle[1]]["Ypos"]]], key=lambda x: x[0]**2 + x[1]**2)
            if edge not in edges:
                edges.append(edge)
        if cones[triangle[2]]["Label"] != cones[triangle[0]]["Label"]:
            edge = sorted([[cones[triangle[0]]["Xpos"], cones[triangle[0]]["Ypos"]],
                           [cones[triangle[2]]["Xpos"], cones[triangle[2]]["Ypos"]]], key=lambda x: x[0]**2 + x[1]**2)
            if edge not in edges:
                edges.append(edge)

    for i in range(len(edges)):
        edges[i] = sorted(edges[i], key=lambda x: x[0]**2 + x[1]**2)

    edges = np.array(edges)
    p1s = edges[:, 0]
    distances1 = [p[0]**2 + p[1]**2 for p in p1s]
    idx1 = distances1.index(min(distances1))
    p2s = edges[:, 1]
    distances2 = [p[0]**2 + p[1]**2 for p in p2s]
    idx2 = distances2.index(min(distances2))
    if distances1[idx1] < distances2[idx2]:
        current_edge = edges[idx1]
        used_indexes = [idx1]
    else:
        current_edge = edges[idx2]
        used_indexes = [idx2]
    ordered_edges = [current_edge]
    for i in range(1, edges.shape[0]):
        found_next_edge = False
        for j in range(edges.shape[0]):
            if j in used_indexes:
                continue
            if np.all(edges[j][0] == current_edge[1]) or np.all(edges[j][1] == current_edge[1]) \
                    or np.all(edges[j][0] == current_edge[0]) or np.all(edges[j][0] == current_edge[0]):
                current_edge = edges[j]
                ordered_edges.append(current_edge)
                used_indexes.append(j)
                found_next_edge = True
                break
        if not found_next_edge:
            break

    midpoints = np.average(ordered_edges, axis=1)

    return midpoints
